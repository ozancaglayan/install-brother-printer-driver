#!/usr/bin/python
# -*- coding: utf-8 -*-

# This is a simple script to install brother printer models
# The script requires rpm2targz tool.

import os
import re
import sys
import dbus
import glob
import shutil
import urllib2
import tempfile
import subprocess
from BeautifulSoup import BeautifulSoup

SUPPORT_PAGE = "http://welcome.solutions.brother.com/bsc/public_s/id/linux/en/download_prn.html"
DEBUG = False
LICENSE_FILE = "/usr/share/brother-driver-installer/LICENSE.driver"

def chunk_read(_response, _output_file, progress_handle, chunk_size=8192):
    total_size = _response.info().getheader('Content-Length').strip()
    total_size = int(total_size)
    bytes_so_far = 0

    output = open(_output_file, "w")

    while 1:
        chunk = _response.read(chunk_size)
        bytes_so_far += len(chunk)

        if not chunk:
            break

        output.write(chunk)

        percent = float(bytes_so_far) / total_size
        percent = round(percent*100, 2)
        progress_handle.setProgressValue(percent)

    output.close()

def exit_with_error(msg):
    print "Error: %s" % msg
    sys.exit(1)

def debug(msg):
    if DEBUG:
        print "Debug: %s" % msg

def ask_for_model(models):
    cmd = ["kdialog", "--title", "Brother Printer Driver Installer",
                      "--menu",  "Please select your printer model:"]

    for index, model in enumerate(models):
        cmd.extend([str(index+1), model])

    stdout = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).stdout
    if stdout:
        index = int(stdout.read().strip())
        return models[index-1]
    else:
        exit_with_error("Can't determine model")

def show_file_list(file_list):
    cmd = ["kdialog", "--title", "List of succesfully installed files",
                      "--textbox", file_list, "500", "400"]

    subprocess.call(cmd)

def parse_url(url):
    # url is 'http://www.brother.com/cgi-bin/agreement/agreement.cgi?dlfile=http://www.brother.com/pub/bsc/linux/dlf/dcp377cwlpr-1.1.2-1.i386.rpm&lang=English_lpr'
    # output is http://www.brother.com/pub/bsc/linux/dlf/dcp377cwlpr-1.1.2-1.i386.rpm
    return re.sub("^.*dlfile=(.*)&.*$", "\\1", url)

def get_progress_dbus_proxy(title, first_label, totalsteps=None):
    cmd = ["kdialog", "--title", title, "--progressbar", first_label]
    if totalsteps:
        cmd.append(totalsteps)
    stdout = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).stdout
    if stdout:
        bus_name, object_path = stdout.read().strip().split()
        bus = dbus.SessionBus()
        proxy = bus.get_object(bus_name, object_path)
        proxy.setProgressValue = lambda x: proxy.get_dbus_method("Set", dbus_interface="org.freedesktop.DBus.Properties")("org.kde.kdialog.ProgressDialog", "value", x)
        return proxy
    else:
        exit_with_error("Can't show progress dialog.")

def main(args):
    clean_up = True
    if "--keep-tmp" in args:
        clean_up = False

    if "--debug" in args:
        global DEBUG
        DEBUG = True

    progress = get_progress_dbus_proxy("Brother Printer Driver Installer",
                                       "Getting driver list from <b><i>http://welcome.solutions.brother.com</i></b>", "0")
    try:
        html_file = urllib2.urlopen(SUPPORT_PAGE)
    except urllib2.URLError:
        exit_with_error("Error: Make sure that the URL '%s' is valid and in-use." % SUPPORT_PAGE)

    progress.setLabelText("Generating the list of supported printers...")
    soup = BeautifulSoup(html_file.read())
    progress.close()

    # Parse the IndexListB <div> to fetch the supported models
    models = [drv.string for drv in \
              soup.find("div", id="IndexListB").findAll("a", href=re.compile('^#[DMHF].*'))]

    # Generate a dictionary model->driver
    model_dict = dict([(model, model) for model in models])

    # Parse the list of alternative drivers and update the dictionary
    for alt_driver in soup.findAll("div", id="AltDriver"):
        children = alt_driver.findChildren(name="a")
        for_model = children[0].get("name")
        use_this = children[1].b.string
        model_dict[for_model] = use_this

    # Let the user pick the printer model and find out the driver
    model = ask_for_model(sorted(model_dict.keys()))
    driver = model_dict[model]

    # Determine what to download for this driver
    urls = [parse_url(a_tag.get("href")) for a_tag in \
            soup.find("div", id="DownloadList").find("a", attrs={"name":driver}).findNext().findNext().findAll("a", href=re.compile("^.*\.i386\.rpm"))]

    # Create a temporary directory
    temp_dir = tempfile.mkdtemp(prefix="brother-")

    # Download them
    progress = get_progress_dbus_proxy("Brother Printer Driver Installer",
                                       "Preparing to download the drivers...")
    for url in urls:
        progress.setProgressValue(0)
        progress.setLabelText("Downloading <b><i>%s</i></b>..." % url)
        response = urllib2.urlopen(url)
        output_file = os.path.join(temp_dir, os.path.basename(url))
        chunk_read(response, output_file, progress)

    progress.setProgressValue(0)
    progress.setLabelText("Please wait while installing <b>Brother %s</b> driver..." % model)

    os.chdir(temp_dir)
    files = None

    # Make sure /var/spool/lpd exists
    if not os.path.exists("/var/spool/lpd"):
        os.makedirs("/var/spool/lpd")

    # Either install them through rpm if it exists or unpack them to the system
    if os.path.exists("/var/lib/rpm"):
        # RPM is found
        cmd = ["rpm", "--force", "-v", "-i", "--nodeps"]
        rpms = [os.path.basename(url) for url in urls]
        cmd.extend(rpms)
        subprocess.call(cmd)

        # Get the list of files that are installed
        cmd = ["rpm", "-ql"]
        cmd.extend([rpm.replace(".rpm", "") for rpm in rpms])
        files = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).stdout.read().split("\n")

        if files:
            open(os.path.join(temp_dir, "filelist"), "w").write("\n".join(files))
            show_file_list(os.path.join(temp_dir, "filelist"))

    else:
        # Hacky way
        os.system("rpm2targz *.rpm &> /dev/null")
        os.system("rm -f *.rpm")
        tarballs = os.listdir(".")

        os.makedirs("install")
        os.chdir("install")

        progress.setProgressValue(25)
        progress.setLabelText("Unpacking drivers...")

        for tarball in tarballs:
            os.system("tar xvf ../%s" % tarball)

        progress.setProgressValue(50)
        progress.setLabelText("Copying files...")

        # Find out the cups wrapper script which will be run after installation
        candidates = glob.glob("usr/local/Brother/cupswrapper/cupswrapper*")
        candidates.extend(glob.glob("opt/brother/Printers/*/cupswrapper/cupswrapper*"))

        if candidates:
            cupswrapper = "/%s" % candidates[0]
        else:
            cupswrapper = None

        # Find out the soname that will be needed in order to satisfy deps
        libs = os.popen("find -type f | xargs file | grep \"LSB exec\" | gawk -F':' '{ print $1 }' | xargs ldd | grep 'not found'").read().strip().split()

        # Copy the files
        for root, dirs, files in os.walk("."):
            for _dir in dirs:
                dirpath = os.path.join("/", root, _dir)
                if not os.path.exists(dirpath):
                    debug(" --> %s" % dirpath)
                    os.makedirs(dirpath)

            for _file in files:
                filepath = os.path.join("/", root, _file)
                if filepath.startswith("/usr/lib/"):
                    # Install to lib32
                    filepath = filepath.replace("/usr/lib/", "/usr/lib32/")
                try:
                    os.unlink(filepath)
                except OSError:
                    pass

                debug(" --> %s" % filepath)
                shutil.copy2(os.path.join(root, _file), filepath)

                # Create library symlinks if needed
                for lib in libs:
                    if os.path.basename(filepath).startswith(lib) and \
                       os.path.basename(filepath) != lib:
                        try:
                            os.unlink(os.path.join("/usr/lib32", lib))
                        except OSError:
                            pass
                        os.symlink(filepath, os.path.join("/usr/lib32", lib))

        progress.setProgressValue(75)
        progress.setLabelText("Running post installation scripts...")

        if cupswrapper:
            # Run postinstall stuff
            os.system("%s -e &>/dev/null" % cupswrapper)
            os.system("%s -i &>/dev/null" % cupswrapper)

    # Run ldconfig in any case
    os.system("ldconfig -X &> /dev/null")

    # Restart CUPS service if OS is Pardus
    # This is already done by cupswrapper using /etc/init.d/cups
    if os.path.exists("/etc/pardus-release"):
        progress.setLabelText("Restarting CUPS service...")
        os.system("/bin/service -q cups restart")
        progress.setProgressValue(90)

    progress.setProgressValue(100)
    progress.setLabelText("Done.")

    # Close progress dialog
    progress.close()

    # Cleanup
    if clean_up:
        os.chdir("/tmp")
        try:
            shutil.rmtree(temp_dir)
        except OSError:
            pass
    else:
        print temp_dir

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
